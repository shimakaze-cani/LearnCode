## 第三章 ARM体系结构与汇编语言



`ARM`处理器中常使用的`Load/Store`指令的使用方法：

```
LDR R1,[R0]           将R0的值作为地址，将该地址上的数据保存到R1
STR R1,[R0]           将R0的值作为地址，将R1的值存储到这个内存地址
LDRB/STRB             每次读写一字节，LDR/STR默认每次读写4字节
LDM/STM               批量加载/存储指令，在一组寄存器和一片内存之间传输数据
SWP R1,R1,[R0]        将R1与R0中地址指向的内存单元中的数据进行交换
SWP R1,R2,[R0]        将[R0]存储到R1，将R2写入[R0]这个内存存储单元
```

经常使用的是`LDR/STR`、`LDM/STM`这两对指令

### 满栈和空栈的区别

如果堆栈指针`SP`总是指向栈顶元素，那么就是满栈  F

如果堆栈指针`SP`指向的是栈顶元素的下一个空闲的存储单元，那么就是空栈  E

每入栈一个元素，栈指针`SP`会往栈增长的方向移动一个存储单元，如果栈指针`SP`从高地址从低地址移动，那么就是递减栈 D 

如果栈指针`SP`从低地址往高地址移动，那么就是递增栈 A

一般`ARM`使用的是满递减堆栈 FD

```
STMFD SP!,{R0-R2,R14}             将R0，R1，R2，R14依次压入内存栈
```

`STMFD`会根据`{}`中的寄存器列表的顺序，从左到右依次压入堆栈

```
LDMFD SP!,{R0-R2,R14}             将内存栈中的数据依次弹出到R14，R2，R1，R0
```

`R0`先入栈 为高地址，`R14`最后入栈，为低地址，`SP`指向`R14`入栈的位置

出栈时SP先弹至`R14`，之后`R2`，`R1`，`R0`，栈中元素依次弹出`R14`、`R2`寄存器后，`SP`指向`R1`

同时ARM提供了`PUSH`和`POP`指令来入栈和出栈

```
PUSH {R0-R2,R14}                 将R0，R1，R2，R14依次压入内存栈
POP {R0-R2,R14}                  将内存栈中的数据依次弹出到R14，R2，R1，R0
```

### 3.2.2 数据传输指令

```
MOV {cond} {S} Rd, operand2
MVN {cond} {S} Rd, operand2
```

`{cond}`条件可选项，`{S}`用来表示是否影响`CPSR`寄存器的值

`MVN`指令用来将操作数`operand2`按位取反后传达进目标寄存器`Rd`，操作数`operand2`可以是一个立即数，也可以是一个寄存器

```
MOV R1, #1                      将立即数1传送到寄存器R1中
MOV R1, R0                      将寄存器R0中的值传入R1
MOV PC, LR                      子程序返回
MVN R0, #OxFF
MVN R0, R1
```

```
ADD							加法
ADC							带进位加法
SUB							减法
AND							逻辑与
ORR							逻辑或
EOR							异或
BIC							位清除指令
```

### 3.2.4 操作数 operand2 详解

操作数 `operand2` 在汇编程序中常用的形式如下两种

```
#constant
Rm{, shift}
```

通过`{, shift}`可选项，可以通过多种移位或循环移位的方式来构建更加灵活的操作数

```
#constant,n                   将立即数constant循环右移n位
ASR #n                        算数右移n位，n的取值范围[1,32]
LSL #n                        逻辑左移n位，n的取值范围[0,31]
LSR #n                        逻辑右移n位，n的取值范围[1,32]
ROR #n                        向右循环移n位，n的取值范围[1,31]
RRX                           向右循环移1位，带扩展
type Rs               仅在ARM中可用 type指ASP、LSL、LSR、RPR， Rs是提供位移量的寄存器名称
```

试例：

```
ADD R3, R2, R1, LSL #3         R3=R2+R1<<3
ADD R3, R2, R1, LSL R0         R3=R2+R1<<R0
ADD IP, IP,  #16, 20           IP=IP+立即数16循环右移20位
```

### 3.2.5 比较指令

比较指令的运算结果会影响`CPSR`寄存器的N、Z、C、V标志位

```
CMP {cond} Rn, operand2         比较两个数大小
CMN {cond} Rn, operand2         取负比较（操作数取负后比较）
```

运行结果`Z=1`时，表示运算结果为0，两个数相等；`N=1`表示运算结果为负；`N=0`表示运算结果为非负，即结果为正或零

### 3.2.7 跳转指令

```
B {cond} label              跳转到标号label处执行
B {cond} Rm                 寄存器Rm中保存的是跳转位置
BL {cond} label
BX {cond} label
BLX {cond} label
```

`B`跳转指令的跳转范围大小为 `[0 , 32MB]`，可以往前跳，也可以往后跳，无条件跳转指令`B`主要用在循环、分支结构的程序中

`BL`跳转指令表示带连接的跳转，在跳转之前，`BL`指令会先将当前指令的下一条指令地址（返回地址）保存到`LR`寄存器中，然后跳转至`label`处执行，一般用于函数调用的场合，子函数执行结束后，`LR`寄存器的地址被赋值给`PC`

`BX`表示带状态切换的切换，`Rm`寄存器中保存的是跳转地址，要跳转的目标地址处可能是`ARM`指令，也可能是`Thumb`指令。处理器根据`Rm[0]`位决定是切换到`ARM`状态还是切换到`Thumb`状态

0：表示目标地址处是`ARM`指令，在跳转之前要先切换至`ARM`状态

1：表示目标地址处是`Thumb`指令，在跳转之前要先切换至`Thumb`状态



