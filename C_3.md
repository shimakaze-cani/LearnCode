## 第三章 ARM体系结构与汇编语言



`ARM`处理器中常使用的`Load/Store`指令的使用方法：

```
LDR R1,[R0]           将R0的值作为地址，将该地址上的数据保存到R1
STR R1,[R0]           将R0的值作为地址，将R1的值存储到这个内存地址
LDRB/STRB             每次读写一字节，LDR/STR默认每次读写4字节
LDM/STM               批量加载/存储指令，在一组寄存器和一片内存之间传输数据
SWP R1,R1,[R0]        将R1与R0中地址指向的内存单元中的数据进行交换
SWP R1,R2,[R0]        将[R0]存储到R1，将R2写入[R0]这个内存存储单元
```

经常使用的是`LDR/STR`、`LDM/STM`这两对指令

### 满栈和空栈的区别

如果堆栈指针`SP`总是指向栈顶元素，那么就是满栈  F

如果堆栈指针`SP`指向的是栈顶元素的下一个空闲的存储单元，那么就是空栈  E

每入栈一个元素，栈指针`SP`会往栈增长的方向移动一个存储单元，如果栈指针`SP`从高地址从低地址移动，那么就是递减栈 D 

如果栈指针`SP`从低地址往高地址移动，那么就是递增栈 A

一般`ARM`使用的是满递减堆栈 FD

```
STMFD SP!,{R0-R2,R14}             将R0，R1，R2，R14依次压入内存栈
```

`STMFD`会根据`{}`中的寄存器列表的顺序，从左到右依次压入堆栈

```
LDMFD SP!,{R0-R2,R14}             将内存栈中的数据依次弹出到R14，R2，R1，R0
```

`R0`先入栈 为高地址，`R14`最后入栈，为低地址，`SP`指向`R14`入栈的位置

出栈时SP先弹至`R14`，之后`R2`，`R1`，`R0`，栈中元素依次弹出`R14`、`R2`寄存器后，`SP`指向`R1`

同时ARM提供了`PUSH`和`POP`指令来入栈和出栈

```
PUSH {R0-R2,R14}                 将R0，R1，R2，R14依次压入内存栈
POP {R0-R2,R14}                  将内存栈中的数据依次弹出到R14，R2，R1，R0
```

### 3.2.2 数据传输指令

```
MOV {cond} {S} Rd, operand2
MVN {cond} {S} Rd, operand2
```

`{cond}`条件可选项，`{S}`用来表示是否影响`CPSR`寄存器的值

`MVN`指令用来将操作数`operand2`按位取反后传达进目标寄存器`Rd`，操作数`operand2`可以是一个立即数，也可以是一个寄存器

```
MOV R1, #1                      将立即数1传送到寄存器R1中
MOV R1, R0                      将寄存器R0中的值传入R1
MOV PC, LR                      子程序返回
MVN R0, #OxFF
MVN R0, R1
```

```
ADD							加法
ADC							带进位加法
SUB							减法
AND							逻辑与
ORR							逻辑或
EOR							异或
BIC							位清除指令
```

### 3.2.4 操作数 operand2 详解

操作数 `operand2` 在汇编程序中常用的形式如下两种

```
#constant
Rm{, shift}
```

通过`{, shift}`可选项，可以通过多种移位或循环移位的方式来构建更加灵活的操作数

```
#constant,n                   将立即数constant循环右移n位
ASR #n                        算数右移n位，n的取值范围[1,32]
LSL #n                        逻辑左移n位，n的取值范围[0,31]
LSR #n                        逻辑右移n位，n的取值范围[1,32]
ROR #n                        向右循环移n位，n的取值范围[1,31]
RRX                           向右循环移1位，带扩展
type Rs               仅在ARM中可用 type指ASP、LSL、LSR、RPR， Rs是提供位移量的寄存器名称
```

试例：

```
ADD R3, R2, R1, LSL #3         R3=R2+R1<<3
ADD R3, R2, R1, LSL R0         R3=R2+R1<<R0
ADD IP, IP,  #16, 20           IP=IP+立即数16循环右移20位
```

### 3.2.5 比较指令

比较指令的运算结果会影响`CPSR`寄存器的N、Z、C、V标志位

```
CMP {cond} Rn, operand2         比较两个数大小
CMN {cond} Rn, operand2         取负比较（操作数取负后比较）
```

运行结果`Z=1`时，表示运算结果为0，两个数相等；`N=1`表示运算结果为负；`N=0`表示运算结果为非负，即结果为正或零

### 3.2.7 跳转指令

```
B {cond} label              跳转到标号label处执行
B {cond} Rm                 寄存器Rm中保存的是跳转位置
BL {cond} label
BX {cond} label
BLX {cond} label
```

`B`跳转指令的跳转范围大小为 `[0 , 32MB]`，可以往前跳，也可以往后跳，无条件跳转指令`B`主要用在循环、分支结构的程序中

`BL`跳转指令表示带连接的跳转，在跳转之前，`BL`指令会先将当前指令的下一条指令地址（返回地址）保存到`LR`寄存器中，然后跳转至`label`处执行，一般用于函数调用的场合，子函数执行结束后，`LR`寄存器的地址被赋值给`PC`

`BX`表示带状态切换的切换，`Rm`寄存器中保存的是跳转地址，要跳转的目标地址处可能是`ARM`指令，也可能是`Thumb`指令。处理器根据`Rm[0]`位决定是切换到`ARM`状态还是切换到`Thumb`状态

0：表示目标地址处是`ARM`指令，在跳转之前要先切换至`ARM`状态

1：表示目标地址处是`Thumb`指令，在跳转之前要先切换至`Thumb`状态

### 3.3 ARM寻址方式

#### 寄存器寻址

通过寄存器名就可以对寄存器中的数据进行读写

```
MOV R1, R2
SUB R1, R2, R3 
```

#### 立即数寻址

立即数以`#`前缀，`0x`前缀表示该立即数为十六进制，不加前缀默认是十进制

```
ADD R1, R1, #1
MOV R1, #0xFF
MOV R1, #12
MOV R1, R1, #16, 20       R1=R1+立即数16循环右移20位
```

常见的移位操作有逻辑移位和算术移位

**逻辑移位**：无论是左移还是右移，空缺位一律补`0`

**算术移位**：左移时空缺位补`0`，右移时空缺位使用符号位填充

#### 寄存器间接寻址

主要用来内存和寄存器之间传输数据，寄存器中保存的是数据在内存中的存储地址

```
LDR R1, [R2]                将R2中的值作为地址，将该地址上的数值，保存至R1
STR R1, [R2]                将R2中的值作为地址，将R1寄存器的值写入该内存地址
```

基址寻址（寄存器间接寻址的一种）

```
LDR R1, [FP, #2]             将FP中的值加2作为新地址，取该地址上的值保存到R1       向后索引寻址
LDR R1, [FP, #2]!            FP=FP+2，然后将FP指定的内存单元数据保存到R1中
LDR R1, [FP, R0]             将FP+R0作为新地址，取该地址上的值保存到R1            向后索引寻址
LDR R1, [FP, R0, LSL #2]     将FP+R0<<2作为新地址，读取该内存地址上的值保存到R1
LDR R1, [FP], #2             将FP中的值作为地址，读取该地址上的值保存到R1，然后FP中的值加2
STR R1, [FP, #-2]            将FP中的值减2，作为新地址，将R1中的值写入该地址       向前索引寻址
STR R1, [FP], #-2            将FP中的值作为地址，将R1中的值写入该地址，然后FP中的值减2  
```

### 3.4 ARM伪指令

```
ADR R0, LOOP                 将标号LOOP的地址保存到R0寄存器中
ADRL R0, LOOP                中等范围的地址读取
LDR R0, =0x30008000          将内存地址0x30008000赋值给R0
NOP                          空操作，用于延时
```

`NOP`相当于 `MOV R0, R0`，比较常用的是`LDR`伪指令，`LDR`伪指令的主要用途就是将一个`32`位的内存地址保存到寄存器

`MOV`指令无法向寄存器传入一个`32`位的数据，编译器提供了一个`LDR`伪指令来完成该功能 （上述第三条指令）

```
LDR R0, =LOOP                将标号LOOP表示的地址传送到R0
LDR R0, LOOP                 将标号LOOP表示的内存地址上的数据送到R0
```

`ADR`伪指令：将基于PC相对偏移的地址值读取到寄存器中，

### 3.6 混合开发 ARPCS

`ARPCS`规则主要内容如下

1. 子程序间通过寄存器`R0~R3`（`a0~a3`）传递参数，当参数个数大于4时，剩余参数使用堆栈传递
2. 子程序通过`R0~R1`返回结果
3. 子程序中通过`R4~R11`（`v1~v8`）来保存局部变量
4. `R12` 为调用过程中的临时寄存器 `IP`
5. `R13` 为堆栈指针寄存器 `SP`
6. `R14` 为链接寄存器，保存函数调用者的返回地址 `LR`
7. `R14` 为程序计数器，总是指向当前正在运行的指令 `PC`



